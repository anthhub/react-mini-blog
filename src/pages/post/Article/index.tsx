import React from 'react'

import { ArticleEntity } from '@/entities/article.entity'
import { translateMarkdown } from '@/lib/utils/markdown'

import { Wrapper } from './style'

interface IProps extends ArticleEntity {}

const data = {
  code: 200,
  message: 'success',
  data: {
    createdAt: '2019-09-19 15:13:04',
    updatedAt: '2019-11-01 15:52:55',
    id: 76,
    title: 'koa-react-ssr  学习',
    content:
      '## koa 创建一个简单的服务器\n\n\n##测试 markdown\n\n```bash\nyarn add koa koa-router\n```\n\n`src/server/app.js`\n\n```js\nconst Koa = require(\'koa\')\nconst Router = require(\'koa-router\')\n\nconst app = new Koa()\nconst router = new Router()\n\nrouter.get(\'*\', async ctx => {\n  ctx.body = `\n  <!DOCTYPE html>\n  <html lang="en">\n    <head>\n      <meta charset="UTF-8" />\n      <title>koa ssr</title>\n    </head>\n    <body>\n      <h1>简单的 koa http 服务</h1>\n      <div id="root"></div>\n    </body>\n  </html>\n  `\n})\n\napp.use(router.routes())\napp.listen(3000, () => {\n  console.log(\'http://127.0.0.1:3000\')\n})\n```\n\n上面我们用 koa 简单创建了一个 `http` 服务，然后返回字符串, `node app.js` 打开 `http://127.0.0.1:3000` 可以看到效果了\n\n## 搞事情，写一个 Home.jsx 组件\n\n`src/client/Home.jsx`\n\n```js\nimport React from \'react\'\nconst Home = () => <h2>Hello world</h2>\nexport default Home\n```\n\n而服务端的 `src/server/app.js` 文件需要改写为\n\n```js\nimport Koa from \'koa\'\nimport Router from \'koa-router\'\nimport ReactDOM from \'react-dom\'\nimport Home from \'../client/Home\'\n\nconst app = new Koa()\nconst router = new Router()\n\n// 原本的在浏览器端的运行方法\n// ReactDOM.render(<Home />, document.getElementById(\'root\'))\n\n// 在服务器端运行的代码\nconst content = ReactDOM.renderToString(<Home />)\n\nrouter.get(\'*\', async ctx => {\n  ctx.body = `\n  <!DOCTYPE html>\n  <html lang="en">\n    <head>\n      <meta charset="UTF-8" />\n      <title>koa ssr</title>\n    </head>\n    <body>\n      <div id="root">${content}</div>\n    </body>\n  </html>\n  `\n})\n\napp.use(router.routes())\napp.listen(3000, () => {\n  console.log(\'http://127.0.0.1:3000\')\n})\n```\n\n上面用到了 `import` / `export` 语法，`node` 不支持，则我们需要使用 `babel` 对它进行转义。\n\n```bash\nyarn init -y\nyarn add webpack webpack-cli -D\nyarn add @babel/core @babel/preset-env @babel/preset-react @babel/runtime @babel/plugin-transform-runtime -D\nyarn add webpack-node-externals -D # 我们不希望捆绑 koa koa-router 等模块...\ntouch webpack.server.js\n```\n\n`webpack.server.js`\n\n```js\nconst path = require(\'path\')\nconst nodeExternals = require(\'webpack-node-externals\')\n\nmodule.exports = {\n  mode: \'production\',\n  target: \'node\',\n  externals: [nodeExternals()], // in order to ignore all modules in node_modules folder\n\n  entry: \'./src/server/app.js\',\n  output: {\n    filename: \'bundle.js\',\n    path: path.resolve(__dirname, \'build\')\n  },\n\n  resolve: {\n    extensions: [\'.js\', \'.json\', \'.jsx\'] // import xxx from \'app.jsx\' => import xxx from \'app\'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \'babel-loader\',\n          options: {\n            // @babel/preset-env 转义 es6+ 的箭头函数、类、async await 等为 ES5 语法\n            // @babel/preset-react : 转义 react\n            // @babel/plugin-transform-runtime : 自动 polyfill es5不支持的特性\n            presets: [\'@babel/preset-env\', \'@babel/preset-react\'],\n            plugins: [\'@babel/plugin-transform-runtime\']\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n在 `package.json` 中添加\n\n```json\n"scripts": {\n  "start": "node ./build/bundle.js",\n  "build:server": "webpack --config webpack.server.js"\n}\n```\n\n```bash\nyarn build:server && yarn start\n```\n\n打开 `http://127.0.0.1:3000/` 就可以看到效果了...\n\n目前为止 我们 webpack 编译了服务端的代码，其中还将 `react` 转成我们需要的形式。已经初步完成了我们的工作...\n\n## 实现同构（添加事件绑定）\n\n服务端渲染和客户端渲染的对比：\n\n![](https://user-gold-cdn.xitu.io/2019/7/2/16bb28547b52c0bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n`CSR` 步骤：\n\n1. 浏览器下载 `HTML` 文档\n2. 浏览器下载 `JS` 文件\n3. 浏览器运行 `React` 代码\n4. 页面渲染\n\n`SSR` 的出现，可以解决这些传统 `CSR` 的弊端, 且可以优化 `SEO` 方便 balabala....\n\n重点是同构如何实现：\n\n![](https://user-gold-cdn.xitu.io/2019/7/2/16bb2b6d8dc96733?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)\n\n1. 服务端运行 `React` 代码生成 `HTML`\n2. 发送 `HTML` 文件给浏览器\n3. 浏览器收到内容显示\n4. 浏览器加载 `JS` 文件\n5. `JS` 代码执行并接管页面的操作\n\n在前面的实现过程中，我们只是运行 `react` 代码生成 `string` 显示在页面中，也仅此而已，那么我们为 `Home.jsx` 添加一个事件绑定试试:\n\n```js\nimport React, { Component } from \'react\'\n\nclass Home extends Component {\n  render() {\n    return (\n      <div>\n        <h2>hello world</h2>\n        <button onClick={() => alert(\'click\')}>click</button>\n      </div>\n    )\n  }\n}\n\nexport default Home\n```\n\n```bash\nyarn build:server && yarn start\n```\n\n发现无论怎么点也没有反应，原因很简单，`react-dom/server` 下的 `renderToString` 并没有做事件相关的处理，因此返回给浏览器的内容不会有事件绑定。\n\n那怎么解决这个问题呢？\n\n这就需要进行同构了。所谓同构，通俗的讲，就是一套 `React` 代码在服务器上运行一遍，到达浏览器又运行一遍。服务端渲染完成页面结构，浏览器端渲染完成事件绑定。\n\n那如何进行浏览器端的事件绑定呢？\n\n唯一的方式就是让浏览器去拉取 `JS` 文件执行，让 `JS` 代码来控制。于是服务端返回的代码变成了这样:\n\n```html\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <title>koa ssr</title>\n  </head>\n  <body>\n    <div id="root">\n      <div data-reactroot="">\n        <h2>hello world</h2>\n        <button>click</button>\n      </div>\n    </div>\n    <script src="/index.js"></script>\n  </body>\n</html>\n```\n\n有没有发现和之前的区别？区别就是多了一个 `script` 标签。而它拉取的 JS 代码就是来完成同构的。\n那么这个 `index.js` 我们如何生产出来呢？\n\n在这里，要用到 `react-dom`。具体做法其实就很简单了：\n\n`src/client/index.js`\n\n```js\nimport React from \'react\'\nimport ReactDOM from \'react-dom\'\nimport Home from \'./Home\'\n\n// ReactDOM.render(<Home />, document.getElementById(\'root\')) 这是浏览器端运行的方式\n\nReactDOM.hydrate(<Home />, document.getElementById(\'root\')) // 服务端渲染用 hydrate\n```\n\n`webpack.client.js`\n\n```js\nconst path = require(\'path\')\n\nmodule.exports = {\n  mode: \'production\',\n\n  entry: \'./src/client/index.js\',\n\n  output: {\n    filename: \'index.js\',\n    path: path.resolve(__dirname, \'public\')\n  },\n\n  resolve: {\n    extensions: [\'.js\', \'.json\', \'.jsx\'] // import xxx from \'app.jsx\' => import xxx from \'app\'\n  },\n\n  module: {\n    rules: [\n      {\n        test: /\\.(js|jsx)$/,\n        exclude: /node_modules/,\n        use: {\n          loader: \'babel-loader\',\n          options: {\n            // @babel/preset-env 转义 es6+ 的箭头函数、类、async await 等为 ES5 语法\n            // @babel/preset-react : 转义 react\n            // @babel/plugin-transform-runtime : 自动 polyfill es5不支持的特性\n            presets: [\'@babel/preset-env\', \'@babel/preset-react\'],\n            plugins: [\'@babel/plugin-transform-runtime\']\n          }\n        }\n      }\n    ]\n  }\n}\n```\n\n`src/server/app.js`\n\n```js\nimport Koa from \'koa\'\nimport Router from \'koa-router\'\nimport serve from \'koa-static\'\nimport path from \'path\'\n\n// react...\nimport React from \'react\'\nimport ReactDOM from \'react-dom/server\'\nimport Home from \'../client/Home\'\nconst app = new Koa()\nconst router = new Router()\n\nconst content = ReactDOM.renderToString(<Home />)\n\n// 设置静态服务器为根路径的 public\napp.use(serve(path.join(process.cwd(), \'/public\')))\n\nrouter.get(\'*\', async ctx => {\n  ctx.body = `\n  <!DOCTYPE html>\n  <html lang="en">\n    <head>\n      <meta charset="UTF-8" />\n      <title>koa ssr</title>\n    </head>\n    <body>\n      <div id="root">${content}</div>\n      <script src=\'/index.js\'></script>\n    </body>\n  </html>\n  `\n})\n\napp.use(router.routes())\napp.listen(3000, () => {\n  console.log(\'http://127.0.0.1:3000\')\n})\n```\n\n`package.json`\n\n```json\n "scripts": {\n    "test": "yarn build:server && yarn build:client && yarn start",\n    "start": "node ./build/bundle.js",\n    "build:server": "webpack --config webpack.server.js",\n    "build:client": "webpack --config webpack.client.js"\n  }\n```\n\n```bash\nyarn add koa-static\nyarn test\n```\n\n打开页面点击后就可以发现事件已经绑定成功了！\n\n## 添加路由\n\n写一个路由的配置文件 `src/client/Routes.js`\n\n```jsx\nimport React, { Component } from \'react\'\nimport { Route } from \'react-router-dom\'\n\nimport Home from \'./Home\'\nimport About from \'./About\'\n\nexport default (\n  <div>\n    <Route path="/" exact component={Home} />\n    <Route path="/about" exact component={About} />\n  </div>\n)\n```\n\n`src/client/About.jsx`\n\n```jsx\nimport React, { Component } from \'react\'\n\nclass About extends Component {\n  render() {\n    return (\n      <div>\n        <h2>About page</h2>\n      </div>\n    )\n  }\n}\n\nexport default About\n```\n\n修改打包 `react` 的入口文件 `src/client/index.js`\n\n```js\nimport React from \'react\'\nimport ReactDOM from \'react-dom\'\nimport { BrowserRouter } from \'react-router-dom\'\nimport Routes from \'./Routes\'\n\nconst App = () => <BrowserRouter>{Routes}</BrowserRouter>\n\nReactDOM.hydrate(<App />, document.getElementById(\'root\')) // 服务端渲染用 hydrate\n```\n\n同时也要修改 `src/server/app.js` 每次请求根据路径不同生成不同的 `content`\n\n```js\nimport Koa from \'koa\'\nimport Router from \'koa-router\'\nimport serve from \'koa-static\'\nimport path from \'path\'\n\n// react...\nimport React from \'react\'\nimport { renderToString } from \'react-dom/server\'\nimport { StaticRouter } from \'react-router-dom\'\n\nimport Routes from \'../client/Routes\'\n\nconst app = new Koa()\nconst router = new Router()\n\n// 设置静态服务器为根路径的 public\napp.use(serve(path.join(process.cwd(), \'/public\')))\n\nrouter.get(\'*\', async ctx => {\n  //构建服务端的路由\n  const content = renderToString(<StaticRouter location={ctx.url}>{Routes}</StaticRouter>)\n\n  ctx.body = `\n  <!DOCTYPE html>\n  <html lang="en">\n    <head>\n      <meta charset="UTF-8" />\n      <title>koa ssr</title>\n    </head>\n    <body>\n      <div id="root">${content}</div>\n      <script src=\'/index.js\'></script>\n    </body>\n  </html>\n  `\n})\n\napp.use(router.routes())\napp.listen(3000, () => {\n  console.log(\'http://127.0.0.1:3000\')\n})\n```\n\n现在路由的跳转就没有任何问题啦。 注意，这里仅仅是一级路由的跳转，多级路由的渲染在之后的系列中会用 `react-router-config` 中 `renderRoutes` 来处理。\n\n## 引入 redux\n\n```bash\nyarn add redux react-redux redux-thunk axios\n```\n\n新建 `src/redux.js` 文件 （为了方便 将配置都写在一个文件）\n\n```js\nimport { combineReducers, compose, createStore, applyMiddleware } from \'redux\'\nimport thunk from \'redux-thunk\'\nimport axios from \'axios\'\n\n// constants\nconst ADD_COUNT = \'ADD_COUNT\'\nconst GET_TITLE = \'GET_TITLE\'\n\n// actions\nexport const addCount = () => ({\n  type: ADD_COUNT\n})\n\nexport const getTitle = () => {\n  return dispatch =>\n    axios.get(\'https://randomuser.me/api/\').then(res => {\n      dispatch({\n        type: GET_TITLE,\n        payload: {\n          title: res.data.results[0].name.title\n        }\n      })\n    })\n}\n\n// default state\nlet defaultState = {\n  count: 1\n}\n\n// reducers\nexport const demoReducer = (state = defaultState, action) => {\n  switch (action.type) {\n    case ADD_COUNT:\n      return { ...state, count: ++state.count }\n    case GET_TITLE:\n      return { ...state, title: action.payload.title }\n    default:\n      return state\n  }\n}\n\n// combineReducers\nconst reducers = combineReducers({\n  demo: demoReducer\n})\n\n// generator store\nconst configureStore = (initialState = {}) => {\n  const storeEnhancers = applyMiddleware(thunk)\n  const store = createStore(reducers, initialState, storeEnhancers)\n  return store\n}\n\n// export\nexport default configureStore()\n```\n\n在客户端中引入 `src/client/index.js`\n\n```js\nimport { Provider } from \'react-redux\'\nimport store from \'../redux\'\n\nconst App = () => (\n  <Provider store={store}>\n    <BrowserRouter>{Routes}</BrowserRouter>\n  </Provider>\n)\n```\n\n在 `src/client/Home.jsx` 中使用\n\n```js\nimport React, { Component } from \'react\'\nimport { connect } from \'react-redux\'\nimport { addCount, getTitle } from \'../redux\'\n\nclass Home extends Component {\n  componentDidMount() {\n    this.props.getTitle()\n  }\n\n  render() {\n    return (\n      <div>\n        <h2>\n          Count: {this.props.count} title: {this.props.title}\n        </h2>\n        <button onClick={this.props.addCount}>add count</button>\n        <button onClick={this.props.getTitle}>async getTitle</button>\n      </div>\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n  count: state.demo.count,\n  title: state.demo.title\n})\n\nexport default connect(\n  mapStateToProps,\n  { addCount, getTitle }\n)(Home)\n```\n\n在服务端中引入 `src/server/app.js`\n\n```js\nimport { Provider } from \'react-redux\'\nimport store from \'../redux\'\n//...\n\nconst content = renderToString(\n  <Provider store={store}>\n    <StaticRouter location={ctx.url}>{Routes}</StaticRouter>\n  </Provider>\n)\n```\n\n`yarn test` 成功编译 说明你成功了\n\n## 异步数据的服务端渲染方案(数据注水与脱水)\n\n经过上面的改造 我们可以在异步获取到了数据。。当然，这是存在坑点的。。\n\n```js\ncomponentDidMount() {\n this.props.getTitle()\n}\n```\n\n我们一般在组件的 `componentDidMount` 生命周期函数进行异步数据的获取。但是，在服务端渲染中却出现了问题。 启动服务后我们查看网页的源代码 可以发现\n\n![](https://user-gold-cdn.xitu.io/2019/7/19/16c09a3ece840c54?w=1152&h=171&f=png&s=39450)\n\n源代码里面并没有这些列表数据啊！那这是为什么呢？\n\n让我们来分析一下客户端和服务端的运行流程，当浏览器发送请求时，服务器接受到请求，这时候服务器和客户端的 `store` 都是空的，紧接着客户端执行 `componentDidMount` 生命周期中的函数，获取到数据并渲染到页面，然而服务器端始终不会执行 componentDidMount，因此不会拿到数据，这也导致服务器端的 `store` 始终是空的。\n\n换而言之，关于异步数据的操作始终只是客户端渲染。现在的工作就是让服务端将获得数据的操作执行一遍，以达到真正的服务端渲染的效果。\n\n',
    viewCount: 167,
    tags: [{ name: 'Javascript' }, { name: 'React' }],
    categories: [{ name: 'Javascript' }, { name: 'React' }],
    comments: [{ createdAt: '2019-10-23 19:04:02', id: 18, content: '到此一游', user: { id: 39449489, username: 'admin', role: 1, github: null }, replies: [] }],
  },
}

const Article: React.FC<IProps> = ({ update_at, content, author, title }) => {
  return (
    <Wrapper>
      <div className="author">
        <div className="author-info">
          <a>
            <div
              className="avatar"
              style={{
                background: 'url(\'https://leancloud-gold-cdn.xitu.io/bdfecd06f90e24f88946.jpeg?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1\') no-repeat center/cover',
              }}
            />
          </a>
          <div>
            <a className="author-name">{author}</a>
            <div className="article-info">
              <time>{update_at}</time>
              {/* <span className="views">阅读 1367</span> */}
            </div>
          </div>
        </div>
        {/* <button className="follow">关注</button> */}
      </div>
      <h1 className="article-title">{title}</h1>
      <div className="article-content">
        <div className="article-detail" dangerouslySetInnerHTML={{ __html: translateMarkdown(data.data.content) }} />
      </div>
    </Wrapper>
  )
}

export default Article
